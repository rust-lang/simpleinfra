// This file configures the crates.io web app API via Fastly CDN

locals {
  fastly_webapp_domain_name = "fastly-app.${var.webapp_domain_name}"
}

# Next-Gen WAF workspace
resource "fastly_ngwaf_workspace" "webapp" {
  name        = "${var.webapp_domain_name}-waf"
  description = "Next-Gen WAF workspace for ${var.webapp_domain_name}"
  # TODO: at some point blog instead of just logging
  mode = "log"

  # Configure when the WAF should flag an IP address as potentially malicious based on cumulative attack signals over different time windows.
  #
  # Fastly's Next-Gen WAF analyzes each request and assigns attack signals when it detects suspicious patterns
  # (SQL injection attempts, XSS, path traversal, etc.). These signals accumulate per IP address over time.
  attack_signal_thresholds {
    # If an IP accumulates 100+ attack signals within 1 minute, it's flagged as an attacker
    one_minute = 100
    # If an IP accumulates 500+ attack signals within 10 minutes, it's flagged
    ten_minutes = 500
    # If an IP accumulates 1000+ attack signals within 1 hour, it's flagged
    one_hour = 1000
    # If true, a single attack signal immediately blocks the IP.
    # We set it to false, to allow for legitimate edge cases
    immediate = false
  }
}

resource "fastly_service_vcl" "webapp" {
  name = var.webapp_domain_name

  lifecycle {
    # IP block list entries are managed manually in the Fastly UI.
    ignore_changes = [acl]
  }

  condition {
    name      = "Generated by IP block list"
    priority  = 0
    statement = "client.ip ~ Generated_by_IP_block_list"
    type      = "REQUEST"
  }

  response_object {
    content_type      = "text/html"
    name              = "Generated by IP block list"
    request_condition = "Generated by IP block list"
    response          = "Forbidden"
    status            = 403
  }

  product_enablement {
    brotli_compression = true
    # Next generation WAF
    ngwaf {
      enabled      = true
      workspace_id = fastly_ngwaf_workspace.webapp.id
    }
  }

  domain {
    name = local.fastly_webapp_domain_name
  }

  domain {
    name = var.webapp_domain_name
  }

  backend {
    name = "crates_io_webapp"

    address       = var.webapp_origin_domain
    override_host = var.webapp_origin_domain

    use_ssl           = true
    port              = 443
    ssl_cert_hostname = var.webapp_origin_domain

    # crates.io accepts crate uploads, so add a longer origin timeout.
    first_byte_timeout    = local.webapp_cdn_timeout_seconds * 1000
    between_bytes_timeout = local.webapp_cdn_timeout_seconds * 1000
  }

  default_ttl = 0

  # Forward relevant headers to the origin
  snippet {
    name    = "forward headers to origin"
    type    = "miss"
    content = <<-VCL
      # Set the Host header for the backend
      set bereq.http.Host = "${var.webapp_origin_domain}";

      # Forward headers from the client request that the backend needs
      # See the cloudfront-webapp.tf for explanations of each header
      set bereq.http.Accept = req.http.Accept;
      set bereq.http.Accept-Encoding = req.http.Accept-Encoding;
      set bereq.http.Referer = req.http.Referer;
      set bereq.http.User-Agent = req.http.User-Agent;
      set bereq.http.X-Request-Id = req.http.X-Request-Id;
      set bereq.http.Authorization = req.http.Authorization;
      set bereq.http.Cookie = req.http.Cookie;
    VCL
  }

  # Pass all requests to origin (no caching for API)
  snippet {
    name    = "pass all requests"
    type    = "recv"
    content = <<-VCL
      # Don't cache any requests - pass directly to origin
      return(pass);
    VCL
  }

  # Handle HSTS headers if strict_security_headers is enabled
  dynamic "snippet" {
    for_each = var.strict_security_headers ? [1] : []
    content {
      name    = "add HSTS header"
      type    = "deliver"
      content = <<-VCL
        set resp.http.Strict-Transport-Security = "max-age=31536000; includeSubDomains";
      VCL
    }
  }
}

module "fastly_tls_subscription_webapp" {
  source = "../fastly-tls-subscription"

  certificate_authority = "globalsign"
  aws_route53_zone_id   = data.aws_route53_zone.webapp.id

  domains = [
    local.fastly_webapp_domain_name,
    var.webapp_domain_name
  ]
}

resource "aws_route53_record" "fastly_webapp_domain" {
  zone_id         = data.aws_route53_zone.webapp.id
  name            = local.fastly_webapp_domain_name
  type            = "CNAME"
  ttl             = 300
  allow_overwrite = true
  records         = module.fastly_tls_subscription_webapp.destinations
}

resource "aws_route53_record" "weighted_webapp_fastly" {
  for_each = toset(var.dns_apex ? [] : [""])

  zone_id = data.aws_route53_zone.webapp.id
  name    = var.webapp_domain_name
  type    = "CNAME"
  ttl     = 300
  records = [aws_route53_record.fastly_webapp_domain.fqdn]

  weighted_routing_policy {
    weight = var.webapp_fastly_weight
  }

  set_identifier = "fastly"
}

data "fastly_tls_configuration" "webapp_tls" {
  id = module.fastly_tls_subscription_webapp.tls_configuration_id

  depends_on = [module.fastly_tls_subscription_webapp]
}

# For apex domains, Route53 cannot alias to a CNAME. Use Fastly anycast IPs instead.
resource "aws_route53_record" "weighted_webapp_fastly_apex" {
  for_each = toset(var.dns_apex ? ["A", "AAAA"] : [])

  zone_id = data.aws_route53_zone.webapp.id
  name    = var.webapp_domain_name
  type    = each.value
  ttl     = 60

  records = [for dns_record in data.fastly_tls_configuration.webapp_tls.dns_records : dns_record.record_value if dns_record.record_type == each.value]

  weighted_routing_policy {
    weight = var.webapp_fastly_weight
  }

  set_identifier = "fastly"
}
