// This file configures the crates.io web app API via Fastly CDN

locals {
  fastly_webapp_domain_name = "fastly-app.${var.webapp_domain_name}"
}

# Next-Gen WAF workspace
resource "fastly_ngwaf_workspace" "webapp" {
  name        = "${var.webapp_domain_name}-waf"
  description = "Next-Gen WAF workspace for ${var.webapp_domain_name}"
  # TODO: at some point `block` instead of just logging
  mode = "log"

  # Configure when the WAF should flag an IP address as potentially malicious based on cumulative attack signals over different time windows.
  #
  # Fastly's Next-Gen WAF analyzes each request and assigns attack signals when it detects suspicious patterns
  # (SQL injection attempts, XSS, path traversal, etc.). These signals accumulate per IP address over time.
  attack_signal_thresholds {
    # If an IP accumulates 100+ attack signals within 1 minute, it's flagged as an attacker
    one_minute = 100
    # If an IP accumulates 500+ attack signals within 10 minutes, it's flagged
    ten_minutes = 500
    # If an IP accumulates 1000+ attack signals within 1 hour, it's flagged
    one_hour = 1000
    # If true, a single attack signal immediately blocks the IP.
    # We set it to false, to allow for legitimate edge cases
    immediate = false
  }
}

# The upload endpoint can legitimately contain payloads that trigger these anomalies.
# Restrict the suppression to PUT /api/v1/crates/new only.
# Signal names retrieved by creating a rule manually and querying the Fastly API for that rule's configuration.
resource "fastly_ngwaf_workspace_rule" "webapp_allow_null_byte_on_crate_upload" {
  workspace_id = fastly_ngwaf_workspace.webapp.id
  type         = "signal"
  description  = "Allow null-byte anomaly for crate uploads"
  enabled      = true

  group_operator = "all"
  condition {
    field    = "method"
    operator = "equals"
    value    = "PUT"
  }
  condition {
    field    = "path"
    operator = "equals"
    value    = "/api/v1/crates/new"
  }

  action {
    type   = "exclude_signal"
    signal = "NULLBYTE"
  }
}

resource "fastly_ngwaf_workspace_rule" "webapp_allow_invalid_encoding_on_crate_upload" {
  workspace_id = fastly_ngwaf_workspace.webapp.id
  type         = "signal"
  description  = "Allow Invalid Encoding anomaly for crate uploads"
  enabled      = true

  group_operator = "all"
  condition {
    field    = "method"
    operator = "equals"
    value    = "PUT"
  }
  condition {
    field    = "path"
    operator = "equals"
    value    = "/api/v1/crates/new"
  }

  action {
    type   = "exclude_signal"
    signal = "NOTUTF8"
  }
}

# Custom signal used for per-client rate limiting in the webapp workspace.
resource "fastly_ngwaf_workspace_signal" "webapp_rate_limit" {
  workspace_id = fastly_ngwaf_workspace.webapp.id
  name         = "webapp-rate-limit"
  description  = "webapp per-IP rate limiting"
}

resource "fastly_ngwaf_workspace_rule" "webapp_per_ip_rate_limit" {
  workspace_id = fastly_ngwaf_workspace.webapp.id
  type         = "rate_limit"
  description  = "Rate limit per client IP to 3,600 requests per hour"
  enabled      = true

  # Fastly NGWAF requires at least one rule condition.
  # Match all request paths so the rate limit applies globally.
  group_operator = "all"
  condition {
    field    = "path"
    operator = "contains"
    value    = "/"
  }

  # If the workspace mode isn't "block", then this rule is not enforced.
  action {
    signal = "site.webapp-rate-limit"
    type   = "block_signal"
  }

  # If an IP sends 600 req in 10 minutes, block them for 5 minutes.
  rate_limit {
    signal = fastly_ngwaf_workspace_signal.webapp_rate_limit.reference_id
    # Maximum number of requests within the evaluation window before the rate limit is triggered.
    threshold = 600
    # Rate limit evaluation window in seconds.
    # Fastly NGWAF only supports rate-limit windows of 1 or 10 minutes.
    # 10 minutes.
    interval = 600
    # How long the rate limit is enforced (in seconds). 5 minutes.
    duration = 300

    client_identifiers {
      type = "ip"
    }
  }
}

resource "fastly_service_vcl" "webapp" {
  name = var.webapp_domain_name

  lifecycle {
    # IP block list entries are managed manually in the Fastly UI.
    ignore_changes = [acl]
  }

  condition {
    name      = "Generated by IP block list"
    priority  = 0
    statement = "client.ip ~ Generated_by_IP_block_list"
    type      = "REQUEST"
  }

  response_object {
    content_type      = "text/html"
    name              = "Generated by IP block list"
    request_condition = "Generated by IP block list"
    response          = "Forbidden"
    status            = 403
  }

  product_enablement {
    brotli_compression = true
    # Next generation WAF
    ngwaf {
      enabled      = true
      workspace_id = fastly_ngwaf_workspace.webapp.id
    }
  }

  domain {
    name = local.fastly_webapp_domain_name
  }

  domain {
    name = var.webapp_domain_name
  }

  backend {
    name = "crates_io_webapp"

    address       = var.webapp_origin_domain
    override_host = var.webapp_origin_domain

    use_ssl           = true
    port              = 443
    ssl_cert_hostname = var.webapp_origin_domain

    # crates.io accepts crate uploads, so add a longer origin timeout.
    first_byte_timeout    = local.webapp_cdn_timeout_seconds * 1000
    between_bytes_timeout = local.webapp_cdn_timeout_seconds * 1000
  }

  default_ttl = 0

  # Forward relevant headers to the origin
  snippet {
    name    = "forward headers to origin"
    type    = "miss"
    content = <<-VCL
      # Set the Host header for the backend
      set bereq.http.Host = "${var.webapp_origin_domain}";

      # Forward headers from the client request that the backend needs
      # See the cloudfront-webapp.tf for explanations of each header
      set bereq.http.Accept = req.http.Accept;
      set bereq.http.Accept-Encoding = req.http.Accept-Encoding;
      set bereq.http.Referer = req.http.Referer;
      set bereq.http.User-Agent = req.http.User-Agent;
      set bereq.http.X-Request-Id = req.http.X-Request-Id;
      set bereq.http.Authorization = req.http.Authorization;
      set bereq.http.Cookie = req.http.Cookie;
    VCL
  }

  # Pass all requests to origin (no caching for API)
  snippet {
    name    = "pass all requests"
    type    = "recv"
    content = <<-VCL
      # Don't cache any requests - pass directly to origin
      return(pass);
    VCL
  }

  # Handle HSTS headers if strict_security_headers is enabled
  dynamic "snippet" {
    for_each = var.strict_security_headers ? [1] : []
    content {
      name    = "add HSTS header"
      type    = "deliver"
      content = <<-VCL
        set resp.http.Strict-Transport-Security = "max-age=31536000; includeSubDomains";
      VCL
    }
  }
}

module "fastly_tls_subscription_webapp" {
  source = "../fastly-tls-subscription"

  certificate_authority = "globalsign"
  aws_route53_zone_id   = data.aws_route53_zone.webapp.id

  domains = [
    local.fastly_webapp_domain_name,
    var.webapp_domain_name
  ]
}

resource "aws_route53_record" "fastly_webapp_domain" {
  zone_id         = data.aws_route53_zone.webapp.id
  name            = local.fastly_webapp_domain_name
  type            = "CNAME"
  ttl             = 300
  allow_overwrite = true
  records         = module.fastly_tls_subscription_webapp.destinations
}

resource "aws_route53_record" "weighted_webapp_fastly" {
  for_each = toset(var.dns_apex ? [] : [""])

  zone_id = data.aws_route53_zone.webapp.id
  name    = var.webapp_domain_name
  type    = "CNAME"
  ttl     = 300
  records = [aws_route53_record.fastly_webapp_domain.fqdn]

  weighted_routing_policy {
    weight = var.webapp_fastly_weight
  }

  set_identifier = "fastly"
}

data "fastly_tls_configuration" "webapp_tls" {
  id = module.fastly_tls_subscription_webapp.tls_configuration_id

  depends_on = [module.fastly_tls_subscription_webapp]
}

# For apex domains, Route53 cannot alias to a CNAME. Use Fastly anycast IPs instead.
resource "aws_route53_record" "weighted_webapp_fastly_apex" {
  for_each = toset(var.dns_apex ? ["A", "AAAA"] : [])

  zone_id = data.aws_route53_zone.webapp.id
  name    = var.webapp_domain_name
  type    = each.value
  ttl     = 60

  records = [for dns_record in data.fastly_tls_configuration.webapp_tls.dns_records : dns_record.record_value if dns_record.record_type == each.value]

  weighted_routing_policy {
    weight = var.webapp_fastly_weight
  }

  set_identifier = "fastly"
}
